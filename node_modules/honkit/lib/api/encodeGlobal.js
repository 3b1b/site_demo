"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const promise_1 = __importDefault(require("../utils/promise"));
const path_2 = __importDefault(require("../utils/path"));
const fs_1 = __importDefault(require("../utils/fs"));
const plugins_1 = __importDefault(require("../plugins"));
const deprecate_1 = __importDefault(require("./deprecate"));
const fileToURL_1 = __importDefault(require("../output/helper/fileToURL"));
const defaultBlocks_1 = __importDefault(require("../constants/defaultBlocks"));
const honkit_1 = __importDefault(require("../honkit"));
const parsers_1 = __importDefault(require("../parsers"));
const encodeConfig_1 = __importDefault(require("./encodeConfig"));
const encodeSummary_1 = __importDefault(require("./encodeSummary"));
const encodeNavigation_1 = __importDefault(require("./encodeNavigation"));
const encodePage_1 = __importDefault(require("./encodePage"));
/**
 Encode a global context into a JS object
 It's the context for page's hook, etc

 @param {Output} output
 @return {Object}
 */
function encodeGlobal(output) {
    const book = output.getBook();
    const bookFS = book.getContentFS();
    const logger = output.getLogger();
    const outputFolder = output.getRoot();
    const plugins = output.getPlugins();
    const blocks = plugins_1.default.listBlocks(plugins);
    const result = {
        log: logger,
        config: encodeConfig_1.default(output, book.getConfig()),
        summary: encodeSummary_1.default(output, book.getSummary()),
        /**
         Check if the book is a multilingual book

         @return {boolean}
         */
        isMultilingual: function () {
            return book.isMultilingual();
        },
        /**
         Check if the book is a language book for a multilingual book

         @return {boolean}
         */
        isLanguageBook: function () {
            return book.isLanguageBook();
        },
        /**
         Read a file from the book

         @param {string} fileName
         @return {Promise<Buffer>}
         */
        readFile: function (fileName) {
            return bookFS.read(fileName);
        },
        /**
         Read a file from the book as a string

         @param {string} fileName
         @return {Promise<String>}
         */
        readFileAsString: function (fileName) {
            return bookFS.readAsString(fileName);
        },
        /**
         Resolve a file from the book root

         @param {string} fileName
         @return {string}
         */
        resolve: function (fileName) {
            return path_1.default.resolve(book.getContentRoot(), fileName);
        },
        /**
         Resolve a page by it path

         @param {string} filePath
         @return {string}
         */
        getPageByPath: function (filePath) {
            const page = output.getPage(filePath);
            if (!page)
                return undefined;
            return encodePage_1.default(output, page);
        },
        /**
         Render a block of text (markdown/asciidoc)

         @param {string} type
         @param {string} text
         @return {Promise<String>}
         */
        renderBlock: function (type, text) {
            const parser = parsers_1.default.get(type);
            return parser.parsePage(text).get("content");
        },
        /**
         Render an inline text (markdown/asciidoc)

         @param {string} type
         @param {string} text
         @return {Promise<String>}
         */
        renderInline: function (type, text) {
            const parser = parsers_1.default.get(type);
            return parser.parseInline(text).get("content");
        },
        template: {
            /**
             Apply a templating block and returns its result

             @param {string} name
             @param {Object} blockData
             @return {Promise|Object}
             */
            applyBlock: function (name, blockData) {
                const block = blocks.get(name) || defaultBlocks_1.default.get(name);
                return promise_1.default(block.applyBlock(blockData, result));
            },
        },
        output: {
            /**
             Name of the generator being used
             {string}
             */
            name: output.getGenerator(),
            /**
             Return absolute path to the root folder of output
             @return {string}
             */
            root: function () {
                return outputFolder;
            },
            /**
             Resolve a file from the output root

             @param {string} fileName
             @return {string}
             */
            resolve: function (fileName) {
                return path_1.default.resolve(outputFolder, fileName);
            },
            /**
             Convert a filepath into an url
             @return {string}
             */
            toURL: function (filePath) {
                return fileToURL_1.default(output, filePath);
            },
            /**
             Check that a file exists.

             @param {string} fileName
             @return {Promise}
             */
            hasFile: function (fileName, content) {
                return promise_1.default().then(() => {
                    // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.
                    const filePath = path_2.default.resolveInRoot(outputFolder, fileName);
                    return fs_1.default.exists(filePath);
                });
            },
            /**
             Write a file to the output folder,
             It creates the required folder

             @param {string} fileName
             @param {Buffer} content
             @return {Promise}
             */
            writeFile: function (fileName, content) {
                return promise_1.default().then(() => {
                    // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.
                    const filePath = path_2.default.resolveInRoot(outputFolder, fileName);
                    return fs_1.default.ensureFile(filePath).then(() => {
                        return fs_1.default.writeFile(filePath, content);
                    });
                });
            },
            /**
             Copy a file to the output folder
             It creates the required folder.

             @param {string} inputFile
             @param {string} outputFile
             @param {Buffer} content
             @return {Promise}
             */
            copyFile: function (inputFile, outputFile, content) {
                return promise_1.default().then(() => {
                    // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.
                    const outputFilePath = path_2.default.resolveInRoot(outputFolder, outputFile);
                    return fs_1.default.ensureFile(outputFilePath).then(() => {
                        return fs_1.default.copy(inputFile, outputFilePath);
                    });
                });
            },
        },
        gitbook: {
            version: honkit_1.default.version,
        },
        honkit: {
            version: honkit_1.default.version,
        },
    };
    // Deprecated properties
    // @ts-expect-error ts-migrate(2554) FIXME: Expected 6 arguments, but got 5.
    deprecate_1.default.renamedMethod(output, "this.isSubBook", result, "isSubBook", "isLanguageBook");
    // @ts-expect-error ts-migrate(2554) FIXME: Expected 6 arguments, but got 5.
    deprecate_1.default.renamedMethod(output, "this.contentLink", result, "contentLink", "output.toURL");
    deprecate_1.default.field(output, "this.generator", result, "generator", output.getGenerator(), '"this.generator" property is deprecated, use "this.output.name" instead');
    deprecate_1.default.field(output, "this.navigation", result, "navigation", () => {
        return encodeNavigation_1.default(output);
    }, '"navigation" property is deprecated');
    deprecate_1.default.field(output, "this.book", result, "book", result, '"book" property is deprecated, use "this" directly instead');
    deprecate_1.default.field(output, "this.options", result, "options", result.config.values, '"options" property is deprecated, use config.get(key) instead');
    return result;
}
exports.default = encodeGlobal;
