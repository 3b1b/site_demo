"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const is_1 = __importDefault(require("is"));
const child_process_1 = __importDefault(require("child_process"));
const spawn_cmd_1 = require("spawn-cmd");
const promise_1 = __importDefault(require("./promise"));
/**
 Execute a command

 @param {string} command
 @param {Object} options
 @return {Promise}
 */
function exec(command, options) {
    const d = promise_1.default.defer();
    const child = child_process_1.default.exec(command, options, (err, stdout, stderr) => {
        if (!err) {
            return d.resolve();
        }
        err.message = stdout.toString("utf8") + stderr.toString("utf8");
        d.reject(err);
    });
    child.stdout.on("data", (data) => {
        d.notify(data);
    });
    child.stderr.on("data", (data) => {
        d.notify(data);
    });
    return d.promise;
}
/**
 Spawn an executable

 @param {string} command
 @param {Array} args
 @param {Object} options
 @return {Promise}
 */
function spawnCmd(command, args, options) {
    const d = promise_1.default.defer();
    const child = spawn_cmd_1.spawn(command, args, options);
    child.on("error", (error) => {
        return d.reject(error);
    });
    child.stdout.on("data", (data) => {
        d.notify(data);
    });
    child.stderr.on("data", (data) => {
        d.notify(data);
    });
    child.on("close", (code) => {
        if (code === 0) {
            d.resolve();
        }
        else {
            d.reject(new Error(`Error with command "${command}"`));
        }
    });
    return d.promise;
}
/**
 Transform an option object to a command line string

 @param {String|number} value
 @param {string}
 */
function escapeShellArg(value) {
    if (is_1.default.number(value)) {
        return value;
    }
    value = String(value);
    value = value.replace(/"/g, '\\"');
    return `"${value}"`;
}
/**
 Transform a map of options into a command line arguments string

 @param {Object} options
 @return {string}
 */
function optionsToShellArgs(options) {
    const result = [];
    for (const key in options) {
        const value = options[key];
        if (value === null || value === undefined || value === false) {
            continue;
        }
        if (typeof value === "boolean") {
            result.push(key);
        }
        else {
            result.push(`${key}=${escapeShellArg(value)}`);
        }
    }
    return result.join(" ");
}
exports.default = {
    exec: exec,
    spawn: spawnCmd,
    optionsToShellArgs: optionsToShellArgs,
};
