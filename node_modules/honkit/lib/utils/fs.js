"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const destroy_1 = __importDefault(require("destroy"));
const tmp_1 = __importDefault(require("tmp"));
const request_1 = __importDefault(require("request"));
const path_1 = __importDefault(require("path"));
const cp_1 = __importDefault(require("cp"));
const cpr_1 = __importDefault(require("cpr"));
const promise_1 = __importDefault(require("./promise"));
// Write a stream to a file
function writeStream(filename, st) {
    const d = promise_1.default.defer();
    const wstream = fs_1.default.createWriteStream(filename);
    const cleanup = function () {
        destroy_1.default(wstream);
        wstream.removeAllListeners();
    };
    wstream.on("finish", () => {
        cleanup();
        d.resolve();
    });
    wstream.on("error", (err) => {
        cleanup();
        d.reject(err);
    });
    st.on("error", (err) => {
        cleanup();
        d.reject(err);
    });
    st.pipe(wstream);
    return d.promise;
}
// Return a promise resolved with a boolean
function fileExists(filename) {
    const d = promise_1.default.defer();
    fs_1.default.stat(filename, (error) => {
        if (error) {
            d.resolve(false);
        }
        else {
            d.resolve(true);
        }
    });
    return d.promise;
}
// Generate temporary file
function genTmpFile(opts) {
    return promise_1.default.nfcall(tmp_1.default.file, opts).get(0);
}
// Generate temporary dir
function genTmpDir(opts) {
    return promise_1.default.nfcall(tmp_1.default.dir, opts).get(0);
}
// Download an image
function download(uri, dest) {
    return writeStream(dest, request_1.default(uri));
}
// Find a filename available in a folder
function uniqueFilename(base, filename) {
    const ext = path_1.default.extname(filename);
    filename = path_1.default.resolve(base, filename);
    filename = path_1.default.join(path_1.default.dirname(filename), path_1.default.basename(filename, ext));
    let _filename = filename + ext;
    let i = 0;
    while (fs_1.default.existsSync(filename)) {
        _filename = `${filename}_${i}${ext}`;
        i = i + 1;
    }
    return promise_1.default(path_1.default.relative(base, _filename));
}
// Create all required folder to create a file
function ensureFile(filename) {
    const base = path_1.default.dirname(filename);
    return promise_1.default(mkdirp_1.default(base));
}
// Remove a folder
function rmDir(base) {
    return promise_1.default.nfcall(fs_1.default.rmdir, base, {
        recursive: true,
    });
}
/**
 Assert a file, if it doesn't exist, call "generator"

 @param {string} filePath
 @param {Function} generator
 @return {Promise}
 */
function assertFile(filePath, generator) {
    return fileExists(filePath).then((exists) => {
        if (exists)
            return;
        return generator();
    });
}
/**
 Pick a file, returns the absolute path if exists, undefined otherwise

 @param {string} rootFolder
 @param {string} fileName
 @return {string}
 */
function pickFile(rootFolder, fileName) {
    const result = path_1.default.join(rootFolder, fileName);
    if (fs_1.default.existsSync(result)) {
        return result;
    }
    return undefined;
}
/**
 Ensure that a directory exists and is empty

 @param {string} folder
 @return {Promise}
 */
function ensureFolder(rootFolder) {
    return rmDir(rootFolder)
        .fail(() => {
        return promise_1.default();
    })
        .then(() => {
        return promise_1.default(mkdirp_1.default(rootFolder));
    });
}
exports.default = {
    exists: fileExists,
    existsSync: fs_1.default.existsSync,
    mkdirp: mkdirp_1.default,
    readFile: promise_1.default.nfbind(fs_1.default.readFile),
    writeFile: (filePath, content) => {
        const d = promise_1.default.defer();
        fs_1.default.writeFile(filePath, content, (error) => {
            if (error) {
                d.reject(error);
            }
            else {
                d.resolve();
            }
        });
        return d.promise;
    },
    assertFile: assertFile,
    pickFile: pickFile,
    stat: promise_1.default.nfbind(fs_1.default.lstat),
    statSync: fs_1.default.lstatSync,
    readdir: promise_1.default.nfbind(fs_1.default.readdir),
    writeStream: writeStream,
    readStream: fs_1.default.createReadStream,
    copy: promise_1.default.nfbind(cp_1.default),
    copyDir: promise_1.default.nfbind(cpr_1.default),
    tmpFile: genTmpFile,
    tmpDir: genTmpDir,
    download: download,
    uniqueFilename: uniqueFilename,
    ensureFile: ensureFile,
    ensureFolder: ensureFolder,
    rmDir: rmDir,
};
