"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const promise_1 = __importDefault(require("../utils/promise"));
const error_1 = __importDefault(require("../utils/error"));
const timing_1 = __importDefault(require("../utils/timing"));
const templating_1 = __importDefault(require("../templating"));
const json_1 = __importDefault(require("../json"));
const createTemplateEngine_1 = __importDefault(require("./createTemplateEngine"));
const callPageHook_1 = __importDefault(require("./callPageHook"));
const page_cache_1 = require("./page-cache");
const page_1 = __importDefault(require("../models/page"));
/**
 * Prepare and generate HTML for a page
 *
 * @param {Output} output
 * @param {Page} page
 * @return {Promise<Page>}
 */
function generatePage(output, page) {
    const book = output.getBook();
    const engine = createTemplateEngine_1.default(output);
    const cache = page_cache_1.getCache();
    return timing_1.default.measure("page.generate", promise_1.default(page).then((resultPage) => {
        const file = resultPage.getFile();
        const filePath = file.getPath();
        const parser = file.getParser();
        const context = json_1.default.encodeOutputWithPage(output, resultPage);
        if (!parser) {
            return promise_1.default.reject(error_1.default.FileNotParsableError({
                filename: filePath,
            }));
        }
        // Call hook "page:before"
        // const start = Date.now();
        return (callPageHook_1.default("page:before", output, resultPage)
            // Escape code blocks with raw tags
            .then((currentPage) => {
            // console.log("page:before", Date.now() - start);
            return parser.preparePage(currentPage.getContent());
        })
            // Render templating syntax
            .then(async (content) => {
            // console.log("page:preparePage", Date.now() - start);
            const absoluteFilePath = path_1.default.join(book.getContentRoot(), filePath);
            // if has compiled pages, use it instead of compiling page
            const pageHash = page.hash();
            const cachedPage = cache.getKey(pageHash);
            if (cachedPage) {
                return page_1.default.fromJSON(output);
            }
            try {
                const output = await templating_1.default.render(engine, absoluteFilePath, content, context);
                // update cache
                cache.setKey(pageHash, page_1.default.toJSON(output));
                return output;
            }
            catch (error) {
                console.error("Template Rendering Error", error);
                console.log("Template content", content);
                throw error;
            }
        })
            .then((output) => {
            // console.log("page:render", Date.now() - start);
            const content = output.getContent();
            return parser.parsePage(content).then((result) => {
                return output.setContent(result.content);
            });
        })
            // Post processing for templating syntax
            .then((output) => {
            // console.log("page:parsePage", Date.now() - start);
            return templating_1.default.postRender(engine, output);
        })
            // Return new page
            .then((content) => {
            // console.log("page:postRender", Date.now() - start);
            return resultPage.set("content", content);
        })
            // Call final hook
            .then((currentPage) => {
            return callPageHook_1.default("page", output, currentPage);
        }));
    }));
}
exports.default = generatePage;
