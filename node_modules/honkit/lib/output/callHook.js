"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promise_1 = __importDefault(require("../utils/promise"));
const timing_1 = __importDefault(require("../utils/timing"));
const api_1 = __importDefault(require("../api"));
function defaultGetArgument() {
    return undefined;
}
function defaultHandleResult(output, result) {
    return output;
}
/**
 Call a "global" hook for an output

 @param {string} name
 @param {Function(Output) -> Mixed} getArgument
 @param {Function(Output, result) -> Output} handleResult
 @param {Output} output
 @return {Promise<Output>}
 */
function callHook(name, getArgument, handleResult, output) {
    getArgument = getArgument || defaultGetArgument;
    handleResult = handleResult || defaultHandleResult;
    const logger = output.getLogger();
    const plugins = output.getPlugins();
    logger.debug.ln(`calling hook "${name}"`);
    // Create the JS context for plugins
    const context = api_1.default.encodeGlobal(output);
    return timing_1.default.measure(`call.hook.${name}`, 
    // Get the arguments
    promise_1.default(getArgument(output))
        // Call the hooks in serie
        .then((arg) => {
        return promise_1.default.reduce(plugins, (prev, plugin) => {
            const hook = plugin.getHook(name);
            if (!hook) {
                return prev;
            }
            return hook.call(context, prev);
        }, arg);
    })
        // Handle final result
        .then((result) => {
        output = api_1.default.decodeGlobal(output, context);
        return handleResult(output, result);
    }));
}
exports.default = callHook;
