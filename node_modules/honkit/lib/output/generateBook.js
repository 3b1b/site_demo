"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.incrementalBuild = exports.generateBook = void 0;
const path_1 = __importDefault(require("path"));
const immutable_1 = __importDefault(require("immutable"));
const output_1 = __importDefault(require("../models/output"));
const promise_1 = __importDefault(require("../utils/promise"));
const fs_1 = __importDefault(require("../utils/fs"));
const callHook_1 = __importDefault(require("./callHook"));
const preparePlugins_1 = __importDefault(require("./preparePlugins"));
const preparePages_1 = __importDefault(require("./preparePages"));
const prepareAssets_1 = __importDefault(require("./prepareAssets"));
const generateAssets_1 = __importDefault(require("./generateAssets"));
const generatePages_1 = __importDefault(require("./generatePages"));
/**
 * Process an output to generate the book
 *
 * @param {Generator} generator
 * @param {Output} output
 * @return {Promise<Output>}
 */
function processOutput(generator, output) {
    return promise_1.default(output)
        .then(preparePlugins_1.default)
        .then(preparePages_1.default)
        .then(prepareAssets_1.default)
        .then(callHook_1.default.bind(null, "config", (output) => {
        const book = output.getBook();
        const config = book.getConfig();
        const values = config.getValues();
        return values.toJS();
    }, (output, result) => {
        let book = output.getBook();
        let config = book.getConfig();
        config = config.updateValues(result);
        book = book.set("config", config);
        return output.set("book", book);
    }))
        .then(callHook_1.default.bind(null, "init", (output) => {
        return {};
    }, (output) => {
        return output;
    }))
        .then((output) => {
        if (!generator.onInit) {
            return output;
        }
        return generator.onInit(output);
    })
        .then((output) => generateAssets_1.default(generator, output))
        .then((output) => generatePages_1.default(generator, output))
        .tap((output) => {
        const book = output.getBook();
        if (!book.isMultilingual()) {
            return;
        }
        const logger = book.getLogger();
        const books = book.getBooks();
        const outputRoot = output.getRoot();
        const plugins = output.getPlugins();
        const state = output.getState();
        const options = output.getOptions();
        const bookList = books.map((langBook) => {
            // Inherits plugins list, options and state
            const langOptions = options.set("root", path_1.default.join(outputRoot, langBook.getLanguage()));
            const langOutput = new output_1.default({
                book: langBook,
                options: langOptions,
                state: state,
                generator: generator.name,
                plugins: plugins,
            });
            logger.info.ln("");
            logger.info.ln(`generating language "${langBook.getLanguage()}"`);
            return processOutput(generator, langOutput);
        });
        return promise_1.default.all(bookList.toArray()).thenResolve(output);
    })
        .then(callHook_1.default.bind(null, "finish:before", (output) => {
        return {};
    }, (output) => {
        return output;
    }))
        .then((output) => {
        if (!generator.onFinish) {
            return output;
        }
        return generator.onFinish(output);
    })
        .then(callHook_1.default.bind(null, "finish", (output) => {
        return {};
    }, (output) => {
        return output;
    }));
}
/**
 * Generate a book using a generator.
 *
 * The overall process is:
 *     1. List and load plugins for this book
 *     2. Call hook "config"
 *     3. Call hook "init"
 *     4. Initialize generator
 *     5. List all assets and pages
 *     6. Copy all assets to output
 *     7. Generate all pages
 *     8. Call hook "finish:before"
 *     9. Finish generation
 *     10. Call hook "finish"
 *
 *
 * @param {Generator} generator
 * @param {Book} book
 * @param {Object} [options = {}]
 * @return {Promise<Output>}
 */
function generateBook(generator, book, options = {}) {
    options = generator.Options(options);
    const state = generator.State ? new generator.State({}) : immutable_1.default.Map();
    const start = Date.now();
    return (promise_1.default(new output_1.default({
        book: book,
        options: options,
        state: state,
        generator: generator.name,
    }))
        // Cleanup output folder
        .then((output) => {
        const logger = output.getLogger();
        const rootFolder = output.getRoot();
        logger.debug.ln(`cleanup folder "${rootFolder}"`);
        return fs_1.default.ensureFolder(rootFolder).thenResolve(output);
    })
        .then(processOutput.bind(null, generator))
        // Log duration and end message
        .then((output) => {
        const logger = output.getLogger();
        const end = Date.now();
        const duration = (end - start) / 1000;
        logger.info.ok(`generation finished with success in ${duration.toFixed(1)}s !`);
        return output;
    }));
}
exports.generateBook = generateBook;
/**
 * Incremental build for pages
 * output should be prepared plugins
 * @param generator
 * @param output
 * @returns {Promise<Promise<Output>>}
 */
function incrementalBuild(generator, output) {
    const start = Date.now();
    return generateAssets_1.default(generator, output)
        .then((output) => generatePages_1.default(generator, output))
        .then((output) => {
        const logger = output.getLogger();
        const end = Date.now();
        const duration = (end - start) / 1000;
        logger.info.ok(`generation finished with success in ${duration.toFixed(1)}s !`);
        return output;
    });
}
exports.incrementalBuild = incrementalBuild;
