"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const immutable_1 = __importDefault(require("immutable"));
const error_1 = __importDefault(require("../utils/error"));
const file_1 = __importDefault(require("./file"));
const glossaryEntry_1 = __importDefault(require("./glossaryEntry"));
const parsers_1 = __importDefault(require("../parsers"));
class Glossary extends immutable_1.default.Record({
    file: new file_1.default(),
    entries: immutable_1.default.OrderedMap(),
}) {
    getFile() {
        return this.get("file");
    }
    getEntries() {
        return this.get("entries");
    }
    /**
     Return an entry by its name
     @param {string} name
     @return {GlossaryEntry}
     */
    getEntry(name) {
        const entries = this.getEntries();
        const id = glossaryEntry_1.default.nameToID(name);
        return entries.get(id);
    }
    /**
     Render glossary as text

     @return {Promise<String>}
     */
    toText(parser) {
        const file = this.getFile();
        const entries = this.getEntries();
        parser = parser ? parsers_1.default.getByExt(parser) : file.getParser();
        if (!parser) {
            throw error_1.default.FileNotParsableError({
                filename: file.getPath(),
            });
        }
        return parser.renderGlossary(entries.toJS());
    }
    /**
     Add/Replace an entry to a glossary

     @param {Glossary} glossary
     @param {GlossaryEntry} entry
     @return {Glossary}
     */
    static addEntry(glossary, entry) {
        const id = entry.getID();
        let entries = glossary.getEntries();
        entries = entries.set(id, entry);
        return glossary.set("entries", entries);
    }
    /**
     Add/Replace an entry to a glossary by name/description
     */
    static addEntryByName(glossary, name, description) {
        const entry = new glossaryEntry_1.default({
            name: name,
            description: description,
        });
        return Glossary.addEntry(glossary, entry);
    }
    /**
     Create a glossary from a list of entries

     @param file
     @param {Array|List} entries
     @return {Glossary}
     */
    static createFromEntries(file, entries) {
        entries = entries.map((entry) => {
            if (!(entry instanceof glossaryEntry_1.default)) {
                entry = new glossaryEntry_1.default(entry);
            }
            return [entry.getID(), entry];
        });
        return new Glossary({
            file: file,
            entries: immutable_1.default.OrderedMap(entries),
        });
    }
}
exports.default = Glossary;
