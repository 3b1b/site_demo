"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const is_1 = __importDefault(require("is"));
const immutable_1 = __importDefault(require("immutable"));
const error_1 = __importDefault(require("../utils/error"));
const location_1 = __importDefault(require("../utils/location"));
const file_1 = __importDefault(require("./file"));
const summaryPart_1 = __importDefault(require("./summaryPart"));
const summaryArticle_1 = __importDefault(require("./summaryArticle"));
const parsers_1 = __importDefault(require("../parsers"));
class Summary extends immutable_1.default.Record({
    file: new file_1.default(),
    parts: immutable_1.default.List(),
}, "Summary") {
    getFile() {
        return this.get("file");
    }
    getParts() {
        return this.get("parts");
    }
    /**
     Return a part by its index
     */
    getPart(i) {
        const parts = this.getParts();
        return parts.get(i);
    }
    /**
     Return an article using an iterator to find it.
     if "partIter" is set, it can also return a Part.

     @param {Function} iter
     @param {Function} [partIter]
     @return {Article|Part}
     */
    getArticle(iter, partIter) {
        const parts = this.getParts();
        return parts.reduce((result, part) => {
            if (result)
                return result;
            if (partIter && partIter(part))
                return part;
            return summaryArticle_1.default.findArticle(part, iter);
        }, null);
    }
    /**
     Return a part/article by its level

     @param {string} level
     @return {Article|Part}
     */
    getByLevel(level) {
        function iterByLevel(article) {
            return article.getLevel() === level;
        }
        return this.getArticle(iterByLevel, iterByLevel);
    }
    /**
     Return an article by its path

     @param {string} filePath
     @return {Article}
     */
    getByPath(filePath) {
        return this.getArticle((article) => {
            const articlePath = article.getPath();
            return articlePath && location_1.default.areIdenticalPaths(articlePath, filePath);
        });
    }
    /**
     Return the first article

     @return {Article}
     */
    getFirstArticle() {
        return this.getArticle((article) => {
            return true;
        });
    }
    /**
     Return next article of an article

     */
    getNextArticle(current) {
        const level = typeof current === "string" ? current : current.getLevel();
        let wasPrev = false;
        return this.getArticle((article) => {
            if (wasPrev && !article.hasAnchor()) {
                return true;
            }
            if (!wasPrev) {
                wasPrev = article.getLevel() === level;
            }
            return false;
        });
    }
    /**
     Return previous article of an article

     @param {Article} current
     @return {Article}
     */
    getPrevArticle(current) {
        const level = is_1.default.string(current) ? current : current.getLevel();
        let prev = undefined;
        this.getArticle((article) => {
            if (article.getLevel() == level) {
                return true;
            }
            if (!article.hasAnchor()) {
                prev = article;
            }
            return false;
        });
        return prev;
    }
    /**
     Return the parent article, or parent part of an article

     @param {String|Article} current
     @return {Article|Part|Null}
     */
    getParent(level) {
        // Coerce to level
        level = is_1.default.string(level) ? level : level.getLevel();
        // Get parent level
        const parentLevel = getParentLevel(level);
        if (!parentLevel) {
            return null;
        }
        // Get parent of the position
        const parentArticle = this.getByLevel(parentLevel);
        return parentArticle || null;
    }
    /**
     Render summary as text

     @param {string} parseExt Extension of the parser to use
     @return {Promise<String>}
     */
    toText(parseExt) {
        const file = this.getFile();
        const parts = this.getParts();
        const parser = parseExt ? parsers_1.default.getByExt(parseExt) : file.getParser();
        if (!parser) {
            throw error_1.default.FileNotParsableError({
                filename: file.getPath(),
            });
        }
        return parser.renderSummary({
            parts: parts.toJS(),
        });
    }
    /**
     Return all articles as a list

     @return {List<Article>}
     */
    getArticlesAsList() {
        const accu = [];
        this.getArticle((article) => {
            accu.push(article);
        });
        return immutable_1.default.List(accu);
    }
    /**
     Create a new summary for a list of parts

     @param {Lust|Array} parts
     @return {Summary}
     */
    static createFromParts(file, parts) {
        parts = parts.map((part, i) => {
            if (part instanceof summaryPart_1.default) {
                return part;
            }
            return summaryPart_1.default.create(part, i + 1);
        });
        return new Summary({
            file: file,
            // @ts-expect-error ts-migrate(2350) FIXME: Only a void function can be called with the 'new' ... Remove this comment to see the full error message
            parts: new immutable_1.default.List(parts),
        });
    }
}
/**
 Returns parent level of a level

 @param {string} level
 @return {string}
 */
function getParentLevel(level) {
    const parts = level.split(".");
    return parts.slice(0, -1).join(".");
}
exports.default = Summary;
